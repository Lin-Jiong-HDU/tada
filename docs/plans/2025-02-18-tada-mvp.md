# tada MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a minimal working terminal AI assistant that can understand natural language and execute shell commands.

**Architecture:** A CLI-first design with three core layers: AI Provider abstraction (OpenAI), simple intent parsing, and synchronous command execution. Configuration via YAML, session persistence via JSON.

**Tech Stack:** Go 1.25.7, OpenAI API, Cobra (CLI), Viper (config), Bubble Tea (TUI for confirmations)

---

## Task 1: Project Foundation - CLI Skeleton

**Files:**
- Create: `cmd/tada/main.go`
- Create: `internal/core/types.go`
- Create: `go.mod` (update dependencies)

**Step 1: Initialize Go modules and dependencies**

Run:
```bash
go mod init github.com/Lin-Jiong-HDU/tada
go get github.com/spf13/cobra@latest
go get github.com/spf13/viper@latest
go get github.com/charmbracelet/bubbletea@latest
```

Expected: `go.mod` and `go.sum` created with dependencies

**Step 2: Write core type definitions**

Create: `internal/core/types.go`
```go
package core

import "context"

// Message represents a chat message
type Message struct {
    Role    string // "system" | "user" | "assistant"
    Content string
}

// Intent represents the parsed user intent
type Intent struct {
    Commands     []Command
    Reason       string
    NeedsConfirm bool
}

// Command represents a shell command to execute
type Command struct {
    Cmd string
    Args []string
}

// Config holds the application configuration
type Config struct {
    AI AIConfig `mapstructure:"ai"`
}

// AIConfig holds AI-related configuration
type AIConfig struct {
    Provider  string `mapstructure:"provider"`
    APIKey    string `mapstructure:"api_key"`
    Model     string `mapstructure:"model"`
    BaseURL   string `mapstructure:"base_url"`
    Timeout   int    `mapstructure:"timeout"`
    MaxTokens int    `mapstructure:"max_tokens"`
}

// AIProvider defines the interface for AI backends
type AIProvider interface {
    ParseIntent(ctx context.Context, input string, systemPrompt string) (*Intent, error)
    AnalyzeOutput(ctx context.Context, cmd string, output string) (string, error)
    Chat(ctx context.Context, messages []Message) (string, error)
}
```

**Step 3: Write the CLI entry point**

Create: `cmd/tada/main.go`
```go
package main

import (
    "fmt"
    "os"

    "github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
    Use:   "tada",
    Short: "Terminal AI assistant",
    Long:  "tada - A terminal AI assistant that understands natural language and executes commands",
    Args:  cobra.MinimumNArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        input := args[0]
        fmt.Printf("ðŸª„ tada received: %s\n", input)
        fmt.Println("(TODO: Implement intent parsing)")
    },
}

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

**Step 4: Test the CLI skeleton**

Run:
```bash
go run cmd/tada/main.go hello world
```

Expected:
```
ðŸª„ tada received: hello
(TODO: Implement intent parsing)
```

**Step 5: Commit**

```bash
git add cmd/tada/main.go internal/core/types.go go.mod go.sum
git commit -m "feat: add CLI skeleton and core types"
```

---

## Task 2: Configuration Management

**Files:**
- Create: `internal/storage/config.go`
- Create: `internal/storage/config_test.go`
- Modify: `cmd/tada/main.go`

**Step 1: Write config storage implementation**

Create: `internal/storage/config.go`
```go
package storage

import (
    "fmt"
    "os"
    "path/filepath"

    "github.com/Lin-Jiong-HDU/tada/internal/core"
    "github.com/spf13/viper"
)

const (
    ConfigFileName = "config"
    ConfigFileType = "yaml"
    TadaDirName    = ".tada"
)

var config *core.Config

// GetConfigDir returns the tada config directory path
func GetConfigDir() (string, error) {
    home, err := os.UserHomeDir()
    if err != nil {
        return "", fmt.Errorf("failed to get home directory: %w", err)
    }
    return filepath.Join(home, TadaDirName), nil
}

// InitConfig initializes the configuration
func InitConfig() (*core.Config, error) {
    configDir, err := GetConfigDir()
    if err != nil {
        return nil, err
    }

    // Create config directory if not exists
    if err := os.MkdirAll(configDir, 0755); err != nil {
        return nil, fmt.Errorf("failed to create config directory: %w", err)
    }

    v := viper.New()
    v.SetConfigName(ConfigFileName)
    v.SetConfigType(ConfigFileType)
    v.AddConfigPath(configDir)

    // Set defaults
    v.SetDefault("ai.provider", "openai")
    v.SetDefault("ai.model", "gpt-4o")
    v.SetDefault("ai.base_url", "https://api.openai.com/v1")
    v.SetDefault("ai.timeout", 30)
    v.SetDefault("ai.max_tokens", 4096)

    // Read config file (ignore if not exists)
    if err := v.ReadInConfig(); err != nil {
        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
            return nil, fmt.Errorf("failed to read config: %w", err)
        }
        // Config not found, will create with defaults
    }

    var cfg core.Config
    if err := v.Unmarshal(&cfg); err != nil {
        return nil, fmt.Errorf("failed to unmarshal config: %w", err)
    }

    config = &cfg
    return config, nil
}

// GetConfig returns the loaded config
func GetConfig() *core.Config {
    return config
}

// SaveConfig saves the current config to file
func SaveConfig(cfg *core.Config) error {
    configDir, err := GetConfigDir()
    if err != nil {
        return err
    }

    v := viper.New()
    v.SetConfigName(ConfigFileName)
    v.SetConfigType(ConfigFileType)
    v.AddConfigPath(configDir)

    v.Set("ai.provider", cfg.AI.Provider)
    v.Set("ai.api_key", cfg.AI.APIKey)
    v.Set("ai.model", cfg.AI.Model)
    v.Set("ai.base_url", cfg.AI.BaseURL)
    v.Set("ai.timeout", cfg.AI.Timeout)
    v.Set("ai.max_tokens", cfg.AI.MaxTokens)

    configPath := filepath.Join(configDir, ConfigFileName+"."+ConfigFileType)
    return v.WriteConfigAs(configPath)
}
```

**Step 2: Write config tests**

Create: `internal/storage/config_test.go`
```go
package storage

import (
    "os"
    "path/filepath"
    "testing"

    "github.com/Lin-Jiong-HDU/tada/internal/core"
)

func TestGetConfigDir(t *testing.T) {
    dir, err := GetConfigDir()
    if err != nil {
        t.Fatalf("GetConfigDir failed: %v", err)
    }

    home, err := os.UserHomeDir()
    if err != nil {
        t.Fatalf("Failed to get home dir: %v", err)
    }

    expected := filepath.Join(home, TadaDirName)
    if dir != expected {
        t.Errorf("Expected %s, got %s", expected, dir)
    }
}

func TestInitConfig(t *testing.T) {
    // Use temp directory for testing
    oldHome := os.Getenv("HOME")
    tmpDir, err := os.MkdirTemp("", "tada-test-*")
    if err != nil {
        t.Fatalf("Failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)
    os.Setenv("HOME", tmpDir)
    defer os.Setenv("HOME", oldHome)

    cfg, err := InitConfig()
    if err != nil {
        t.Fatalf("InitConfig failed: %v", err)
    }

    // Check defaults
    if cfg.AI.Provider != "openai" {
        t.Errorf("Expected provider 'openai', got '%s'", cfg.AI.Provider)
    }
    if cfg.AI.Model != "gpt-4o" {
        t.Errorf("Expected model 'gpt-4o', got '%s'", cfg.AI.Model)
    }
}

func TestSaveConfig(t *testing.T) {
    oldHome := os.Getenv("HOME")
    tmpDir, err := os.MkdirTemp("", "tada-test-*")
    if err != nil {
        t.Fatalf("Failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)
    os.Setenv("HOME", tmpDir)
    defer os.Setenv("HOME", oldHome)

    cfg := &core.Config{
        AI: core.AIConfig{
            Provider:  "test",
            APIKey:    "test-key",
            Model:     "test-model",
            BaseURL:   "https://test.com",
            Timeout:   60,
            MaxTokens: 2048,
        },
    }

    err = SaveConfig(cfg)
    if err != nil {
        t.Fatalf("SaveConfig failed: %v", err)
    }

    // Verify file exists
    configDir, _ := GetConfigDir()
    configPath := filepath.Join(configDir, ConfigFileName+"."+ConfigFileType)
    if _, err := os.Stat(configPath); os.IsNotExist(err) {
        t.Errorf("Config file was not created")
    }
}
```

**Step 3: Run tests to verify they pass**

Run:
```bash
go test ./internal/storage/... -v
```

Expected: All tests PASS

**Step 4: Update main.go to initialize config**

Modify: `cmd/tada/main.go`
```go
package main

import (
    "fmt"
    "os"

    "github.com/Lin-Jiong-HDU/tada/internal/storage"
    "github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
    Use:   "tada",
    Short: "Terminal AI assistant",
    Long:  "tada - A terminal AI assistant that understands natural language and executes commands",
    Args:  cobra.MinimumNArgs(1),
    PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
        _, err := storage.InitConfig()
        return err
    },
    Run: func(cmd *cobra.Command, args []string) {
        cfg := storage.GetConfig()
        input := args[0]
        fmt.Printf("ðŸª„ tada received: %s\n", input)
        fmt.Printf("Config: AI Provider = %s, Model = %s\n", cfg.AI.Provider, cfg.AI.Model)
    },
}

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

**Step 5: Test the config integration**

Run:
```bash
go run cmd/tada/main.go hello
```

Expected: Output shows config values

**Step 6: Commit**

```bash
git add internal/storage/ cmd/tada/main.go
git commit -m "feat: add configuration management with viper"
```

---

## Task 3: OpenAI Provider Implementation

**Files:**
- Create: `internal/ai/provider.go` (interface already in types.go, move it here)
- Create: `internal/ai/openai/client.go`
- Create: `internal/ai/openai/client_test.go`

**Step 1: Move AIProvider interface to ai package**

Create: `internal/ai/provider.go`
```go
package ai

import "context"

// Message represents a chat message
type Message struct {
    Role    string // "system" | "user" | "assistant"
    Content string
}

// Intent represents the parsed user intent
type Intent struct {
    Commands     []Command
    Reason       string
    NeedsConfirm bool
}

// Command represents a shell command to execute
type Command struct {
    Cmd string
    Args []string
}

// AIProvider defines the interface for AI backends
type AIProvider interface {
    ParseIntent(ctx context.Context, input string, systemPrompt string) (*Intent, error)
    AnalyzeOutput(ctx context.Context, cmd string, output string) (string, error)
    Chat(ctx context.Context, messages []Message) (string, error)
}
```

**Step 2: Implement OpenAI client**

Create: `internal/ai/openai/client.go`
```go
package openai

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/Lin-Jiong-HDU/tada/internal/ai"
)

const (
    defaultSystemPrompt = `You are tada, a terminal AI assistant. Your job is to understand user requests and convert them into shell commands.

Rules:
1. Return ONLY valid JSON
2. For simple requests, return a single command
3. Explain your reasoning in the "reason" field
4. Mark dangerous commands (rm, chmod, etc.) with needs_confirm: true

Response format:
{
  "commands": [{"cmd": "command", "args": ["arg1", "arg2"]}],
  "reason": "explanation",
  "needs_confirm": false
}`
)

// Client implements AIProvider for OpenAI
type Client struct {
    apiKey  string
    model   string
    baseURL string
}

// NewClient creates a new OpenAI client
func NewClient(apiKey, model, baseURL string) *Client {
    return &Client{
        apiKey:  apiKey,
        model:   model,
        baseURL: baseURL,
    }
}

// ParseIntent parses user input and returns intent
func (c *Client) ParseIntent(ctx context.Context, input string, systemPrompt string) (*ai.Intent, error) {
    if systemPrompt == "" {
        systemPrompt = defaultSystemPrompt
    }

    prompt := fmt.Sprintf("User request: %s\n\nConvert this to shell commands. Return JSON only.", input)

    response, err := c.callAPI(ctx, []ai.Message{
        {Role: "system", Content: systemPrompt},
        {Role: "user", Content: prompt},
    })
    if err != nil {
        return nil, err
    }

    return c.parseIntentResponse(response)
}

// AnalyzeOutput analyzes command output
func (c *Client) AnalyzeOutput(ctx context.Context, cmd string, output string) (string, error) {
    prompt := fmt.Sprintf("Command: %s\nOutput:\n%s\n\nBriefly explain what happened (max 2 sentences).", cmd, output)

    response, err := c.callAPI(ctx, []ai.Message{
        {Role: "system", Content: "You are a helpful assistant. Be brief and clear."},
        {Role: "user", Content: prompt},
    })
    if err != nil {
        return "", err
    }

    return response, nil
}

// Chat handles general conversation
func (c *Client) Chat(ctx context.Context, messages []ai.Message) (string, error) {
    return c.callAPI(ctx, messages)
}

// callAPI makes the actual API call
func (c *Client) callAPI(ctx context.Context, messages []ai.Message) (string, error) {
    // TODO: Implement actual HTTP call to OpenAI API
    // For now, return a mock response
    return "Mock response - implement HTTP client", nil
}

// parseIntentResponse parses JSON response into Intent
func (c *Client) parseIntentResponse(response string) (*ai.Intent, error) {
    var intent ai.Intent
    if err := json.Unmarshal([]byte(response), &intent); err != nil {
        return nil, fmt.Errorf("failed to parse intent: %w", err)
    }
    return &intent, nil
}
```

**Step 3: Write tests for OpenAI client**

Create: `internal/ai/openai/client_test.go`
```go
package openai

import (
    "context"
    "testing"

    "github.com/Lin-Jiong-HDU/tada/internal/ai"
)

func TestNewClient(t *testing.T) {
    client := NewClient("test-key", "gpt-4", "https://api.openai.com/v1")

    if client == nil {
        t.Fatal("NewClient returned nil")
    }
    if client.apiKey != "test-key" {
        t.Errorf("Expected apiKey 'test-key', got '%s'", client.apiKey)
    }
    if client.model != "gpt-4" {
        t.Errorf("Expected model 'gpt-4', got '%s'", client.model)
    }
}

func TestParseIntentResponse(t *testing.T) {
    client := NewClient("key", "model", "url")
    jsonResp := `{
        "commands": [{"cmd": "mkdir", "args": ["docs"]}],
        "reason": "Creating directory",
        "needs_confirm": false
    }`

    intent, err := client.parseIntentResponse(jsonResp)
    if err != nil {
        t.Fatalf("parseIntentResponse failed: %v", err)
    }

    if len(intent.Commands) != 1 {
        t.Errorf("Expected 1 command, got %d", len(intent.Commands))
    }
    if intent.Commands[0].Cmd != "mkdir" {
        t.Errorf("Expected cmd 'mkdir', got '%s'", intent.Commands[0].Cmd)
    }
    if intent.Reason != "Creating directory" {
        t.Errorf("Expected reason 'Creating directory', got '%s'", intent.Reason)
    }
}

func TestParseIntentResponse_InvalidJSON(t *testing.T) {
    client := NewClient("key", "model", "url")
    jsonResp := `{invalid json}`

    _, err := client.parseIntentResponse(jsonResp)
    if err == nil {
        t.Error("Expected error for invalid JSON, got nil")
    }
}
```

**Step 4: Run tests**

Run:
```bash
go test ./internal/ai/openai/... -v
```

Expected: All tests PASS (callAPI returns mock)

**Step 5: Commit**

```bash
git add internal/ai/
git commit -m "feat: add OpenAI provider with interface definition"
```

---

## Task 4: Complete OpenAI HTTP Client

**Files:**
- Modify: `internal/ai/openai/client.go`

**Step 1: Implement actual HTTP call**

Modify: `internal/ai/openai/client.go`
```go
package openai

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"

    "github.com/Lin-Jiong-HDU/tada/internal/ai"
)

// ... (keep existing code, update callAPI method)

// callAPI makes the actual API call
func (c *Client) callAPI(ctx context.Context, messages []ai.Message) (string, error) {
    reqBody := map[string]interface{}{
        "model":    c.model,
        "messages": messages,
    }

    jsonBody, err := json.Marshal(reqBody)
    if err != nil {
        return "", fmt.Errorf("failed to marshal request: %w", err)
    }

    req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/chat/completions", bytes.NewReader(jsonBody))
    if err != nil {
        return "", fmt.Errorf("failed to create request: %w", err)
    }

    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+c.apiKey)

    client := &http.Client{Timeout: 30 * time.Second}
    resp, err := client.Do(req)
    if err != nil {
        return "", fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return "", fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
    }

    var respData struct {
        Choices []struct {
            Message struct {
                Content string `json:"content"`
            } `json:"message"`
        } `json:"choices"`
    }

    if err := json.NewDecoder(resp.Body).Decode(&respData); err != nil {
        return "", fmt.Errorf("failed to decode response: %w", err)
    }

    if len(respData.Choices) == 0 {
        return "", fmt.Errorf("no choices in response")
    }

    return respData.Choices[0].Message.Content, nil
}
```

**Step 2: Update tests to handle real API call as optional**

Modify: `internal/ai/openai/client_test.go`
```go
// Add integration test (only run with TADA_INTEGRATION_TEST=1)
func TestIntegration_RealAPI(t *testing.T) {
    if os.Getenv("TADA_INTEGRATION_TEST") == "" {
        t.Skip("Set TADA_INTEGRATION_TEST=1 to run integration tests")
    }

    apiKey := os.Getenv("OPENAI_API_KEY")
    if apiKey == "" {
        t.Skip("OPENAI_API_KEY not set")
    }

    client := NewClient(apiKey, "gpt-4o-mini", "https://api.openai.com/v1")
    response, err := client.Chat(context.Background(), []ai.Message{
        {Role: "user", Content: "Say 'Hello, tada!'"},
    })

    if err != nil {
        t.Fatalf("Chat failed: %v", err)
    }

    if response == "" {
        t.Error("Expected non-empty response")
    }

    t.Logf("Response: %s", response)
}
```

**Step 3: Run tests**

Run:
```bash
go test ./internal/ai/openai/... -v
```

Expected: Unit tests pass

**Step 4: Test integration with real API (optional)**

Run:
```bash
TADA_INTEGRATION_TEST=1 OPENAI_API_KEY=your-key go test ./internal/ai/openai/... -v -run TestIntegration
```

**Step 5: Commit**

```bash
git add internal/ai/openai/client.go internal/ai/openai/client_test.go
git commit -m "feat: implement OpenAI HTTP client"
```

---

## Task 5: Command Executor

**Files:**
- Create: `internal/core/executor.go`
- Create: `internal/core/executor_test.go`

**Step 1: Implement command executor**

Create: `internal/core/executor.go`
```go
package core

import (
    "bytes"
    "context"
    "fmt"
    "os/exec"
    "strings"
    "time"
)

// Executor handles command execution
type Executor struct {
    timeout time.Duration
}

// NewExecutor creates a new executor
func NewExecutor(timeout time.Duration) *Executor {
    return &Executor{
        timeout: timeout,
    }
}

// Result represents command execution result
type Result struct {
    Output   string
    ExitCode int
    Error    error
}

// Execute runs a command and returns the result
func (e *Executor) Execute(ctx context.Context, cmd Command) (*Result, error) {
    ctx, cancel := context.WithTimeout(ctx, e.timeout)
    defer cancel()

    // Build command with args
    cmdParts := append([]string{cmd.Cmd}, cmd.Args...)
    execCmd := exec.CommandContext(ctx, cmdParts[0], cmdParts[1:]...)

    var stdout, stderr bytes.Buffer
    execCmd.Stdout = &stdout
    execCmd.Stderr = &stderr

    err := execCmd.Run()

    output := stdout.String()
    if stderr.Len() > 0 {
        output += "\n" + stderr.String()
    }

    result := &Result{
        Output: strings.TrimSpace(output),
    }

    if err != nil {
        if exitError, ok := err.(*exec.ExitError); ok {
            result.ExitCode = exitError.ExitCode()
        }
        result.Error = err
    }

    return result, nil
}

// ExecuteBatch runs multiple commands sequentially
func (e *Executor) ExecuteBatch(ctx context.Context, commands []Command) ([]*Result, error) {
    results := make([]*Result, len(commands))

    for i, cmd := range commands {
        result, err := e.Execute(ctx, cmd)
        if err != nil {
            return results, fmt.Errorf("command %d failed: %w", i+1, err)
        }
        results[i] = result

        // Stop if command failed
        if result.Error != nil {
            break
        }
    }

    return results, nil
}
```

**Step 2: Write tests**

Create: `internal/core/executor_test.go`
```go
package core

import (
    "context"
    "testing"
    "time"
)

func TestExecute_SimpleCommand(t *testing.T) {
    executor := NewExecutor(5 * time.Second)

    result, err := executor.Execute(context.Background(), Command{
        Cmd: "echo",
        Args: []string{"hello", "world"},
    })

    if err != nil {
        t.Fatalf("Execute failed: %v", err)
    }

    if result.Output != "hello world" {
        t.Errorf("Expected 'hello world', got '%s'", result.Output)
    }
    if result.ExitCode != 0 {
        t.Errorf("Expected exit code 0, got %d", result.ExitCode)
    }
}

func TestExecute_CommandNotFound(t *testing.T) {
    executor := NewExecutor(5 * time.Second)

    result, err := executor.Execute(context.Background(), Command{
        Cmd: "nonexistent-command-xyz123",
    })

    if err == nil {
        t.Error("Expected error for nonexistent command")
    }
    if result.ExitCode == 0 {
        t.Error("Expected non-zero exit code")
    }
}

func TestExecuteBatch_MultipleCommands(t *testing.T) {
    executor := NewExecutor(5 * time.Second)

    commands := []Command{
        {Cmd: "echo", Args: []string{"first"}},
        {Cmd: "echo", Args: []string{"second"}},
    }

    results, err := executor.ExecuteBatch(context.Background(), commands)
    if err != nil {
        t.Fatalf("ExecuteBatch failed: %v", err)
    }

    if len(results) != 2 {
        t.Errorf("Expected 2 results, got %d", len(results))
    }
    if results[0].Output != "first" {
        t.Errorf("Expected 'first', got '%s'", results[0].Output)
    }
    if results[1].Output != "second" {
        t.Errorf("Expected 'second', got '%s'", results[1].Output)
    }
}
```

**Step 3: Run tests**

Run:
```bash
go test ./internal/core/... -v
```

Expected: All tests PASS

**Step 4: Commit**

```bash
git add internal/core/executor.go internal/core/executor_test.go
git commit -m "feat: add command executor with timeout support"
```

---

## Task 6: Main Engine Integration

**Files:**
- Create: `internal/core/engine.go`
- Modify: `cmd/tada/main.go`

**Step 1: Implement main engine**

Create: `internal/core/engine.go`
```go
package core

import (
    "context"
    "fmt"

    "github.com/Lin-Jiong-HDU/tada/internal/ai"
)

// Engine orchestrates the AI workflow
type Engine struct {
    ai        ai.AIProvider
    executor  *Executor
}

// NewEngine creates a new engine
func NewEngine(aiProvider ai.AIProvider, executor *Executor) *Engine {
    return &Engine{
        ai:       aiProvider,
        executor: executor,
    }
}

// Process handles a user request from input to output
func (e *Engine) Process(ctx context.Context, input string, systemPrompt string) error {
    // Step 1: Parse intent
    fmt.Println("ðŸ§  Thinking...")
    intent, err := e.ai.ParseIntent(ctx, input, systemPrompt)
    if err != nil {
        return fmt.Errorf("failed to parse intent: %w", err)
    }

    fmt.Printf("ðŸ“ Plan: %s\n", intent.Reason)

    // Step 2: Confirm if needed
    if intent.NeedsConfirm {
        // TODO: Implement TUI confirmation
        fmt.Println("âš ï¸  This command requires confirmation.")
        // For MVP, auto-confirm with warning
        fmt.Println("âš ï¸  Proceeding (confirmation will be added in TUI phase)...")
    }

    // Step 3: Execute commands
    for i, cmd := range intent.Commands {
        fmt.Printf("\nðŸ”§ Executing [%d/%d]: %s %v\n", i+1, len(intent.Commands), cmd.Cmd, cmd.Args)

        result, err := e.executor.Execute(ctx, cmd)
        if err != nil {
            fmt.Printf("âŒ Error: %v\n", err)
            continue
        }

        // Show output (truncated if too long)
        e.displayOutput(result.Output)

        // Step 4: Analyze result
        if result.Error != nil {
            fmt.Printf("ðŸ“Š Command failed (exit code %d)\n", result.ExitCode)
        } else {
            analysis, err := e.ai.AnalyzeOutput(ctx, cmd.Cmd, result.Output)
            if err != nil {
                fmt.Printf("âš ï¸  Could not analyze output\n")
            } else {
                fmt.Printf("âœ… %s\n", analysis)
            }
        }
    }

    return nil
}

// displayOutput shows command output with truncation
func (e *Engine) displayOutput(output string) {
    maxLines := 20
    lines := splitLines(output)

    if len(lines) > maxLines {
        fmt.Printf("ðŸ“„ Output (%d lines, showing first %d):\n", len(lines), maxLines)
        for i := 0; i < maxLines; i++ {
            fmt.Printf("  %s\n", lines[i])
        }
        fmt.Printf("  ... (%d more lines)\n", len(lines)-maxLines)
    } else {
        fmt.Printf("ðŸ“„ Output:\n%s\n", output)
    }
}

func splitLines(s string) []string {
    lines := make([]string, 0)
    current := ""
    for _, ch := range s {
        if ch == '\n' {
            lines = append(lines, current)
            current = ""
        } else {
            current += string(ch)
        }
    }
    if current != "" {
        lines = append(lines, current)
    }
    return lines
}
```

**Step 2: Update main.go to use engine**

Modify: `cmd/tada/main.go`
```go
package main

import (
    "context"
    "fmt"
    "os"
    "time"

    "github.com/Lin-Jiong-HDU/tada/internal/ai/openai"
    "github.com/Lin-Jiong-HDU/tada/internal/core"
    "github.com/Lin-Jiong-HDU/tada/internal/storage"
    "github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
    Use:   "tada",
    Short: "Terminal AI assistant",
    Long:  "tada - A terminal AI assistant that understands natural language and executes commands",
    Args:  cobra.MinimumNArgs(1),
    PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
        _, err := storage.InitConfig()
        return err
    },
    Run: func(cmd *cobra.Command, args []string) {
        cfg := storage.GetConfig()
        input := args[0]

        // Validate config
        if cfg.AI.APIKey == "" {
            fmt.Fprintf(os.Stderr, "âŒ Error: AI API key not configured. Please set it in ~/.tada/config.yaml\n")
            fmt.Fprintf(os.Stderr, "Example:\n  ai:\n    api_key: sk-xxx\n")
            os.Exit(1)
        }

        // Initialize components
        aiClient := openai.NewClient(cfg.AI.APIKey, cfg.AI.Model, cfg.AI.BaseURL)
        executor := core.NewExecutor(30 * time.Second)
        engine := core.NewEngine(aiClient, executor)

        // Process request
        if err := engine.Process(context.Background(), input, ""); err != nil {
            fmt.Fprintf(os.Stderr, "âŒ Error: %v\n", err)
            os.Exit(1)
        }
    },
}

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

**Step 3: Test the full flow**

Run:
```bash
# First, set up config with API key
mkdir -p ~/.tada
cat > ~/.tada/config.yaml << 'EOF'
ai:
  provider: openai
  api_key: YOUR_API_KEY_HERE
  model: gpt-4o-mini
  base_url: https://api.openai.com/v1
  timeout: 30
  max_tokens: 4096
EOF

# Then test
go run cmd/tada/main.go "åˆ—å‡ºå½“å‰ç›®å½•çš„æ–‡ä»¶"
```

Expected:
```
ðŸ§  Thinking...
ðŸ“ Plan: ä½¿ç”¨ ls å‘½ä»¤åˆ—å‡ºå½“å‰ç›®å½•çš„æ–‡ä»¶
ðŸ”§ Executing [1/1]: ls []
ðŸ“„ Output:
...
âœ… å·²æˆåŠŸåˆ—å‡ºå½“å‰ç›®å½•çš„æ–‡ä»¶
```

**Step 4: Commit**

```bash
git add internal/core/engine.go cmd/tada/main.go
git commit -m "feat: integrate main engine with CLI"
```

---

## Task 7: Session Persistence

**Files:**
- Create: `internal/storage/session.go`
- Create: `internal/storage/session_test.go`
- Modify: `internal/core/engine.go`

**Step 1: Implement session storage**

Create: `internal/storage/session.go`
```go
package storage

import (
    "encoding/json"
    "fmt"
    "os"
    "path/filepath"
    "time"

    "github.com/Lin-Jiong-HDU/tada/internal/ai"
)

const (
    SessionDirName = "sessions"
    CurrentSession = "current.json"
    MaxHistory     = 100
)

// Session represents a conversation session
type Session struct {
    ID        string     `json:"id"`
    StartedAt time.Time  `json:"started_at"`
    UpdatedAt time.Time  `json:"updated_at"`
    Messages  []ai.Message `json:"messages"`
}

var currentSession *Session

// InitSession initializes or loads the current session
func InitSession() (*Session, error) {
    configDir, err := GetConfigDir()
    if err != nil {
        return nil, err
    }

    sessionDir := filepath.Join(configDir, SessionDirName)
    if err := os.MkdirAll(sessionDir, 0755); err != nil {
        return nil, fmt.Errorf("failed to create session directory: %w", err)
    }

    sessionPath := filepath.Join(sessionDir, CurrentSession)

    // Try to load existing session
    if data, err := os.ReadFile(sessionPath); err == nil {
        var session Session
        if err := json.Unmarshal(data, &session); err != nil {
            return nil, fmt.Errorf("failed to unmarshal session: %w", err)
        }
        currentSession = &session
        return currentSession, nil
    }

    // Create new session
    session := Session{
        ID:        generateSessionID(),
        StartedAt: time.Now(),
        UpdatedAt: time.Now(),
        Messages:  []ai.Message{},
    }

    currentSession = &session
    return currentSession, nil
}

// GetCurrentSession returns the current session
func GetCurrentSession() *Session {
    return currentSession
}

// SaveSession saves the current session
func SaveSession() error {
    if currentSession == nil {
        return nil
    }

    configDir, err := GetConfigDir()
    if err != nil {
        return err
    }

    sessionPath := filepath.Join(configDir, SessionDirName, CurrentSession)

    currentSession.UpdatedAt = time.Now()

    // Trim to max history
    if len(currentSession.Messages) > MaxHistory {
        currentSession.Messages = currentSession.Messages[len(currentSession.Messages)-MaxHistory:]
    }

    data, err := json.MarshalIndent(currentSession, "", "  ")
    if err != nil {
        return fmt.Errorf("failed to marshal session: %w", err)
    }

    if err := os.WriteFile(sessionPath, data, 0644); err != nil {
        return fmt.Errorf("failed to write session: %w", err)
    }

    return nil
}

// AddMessage adds a message to the session
func AddMessage(role, content string) {
    if currentSession == nil {
        return
    }

    currentSession.Messages = append(currentSession.Messages, ai.Message{
        Role:    role,
        Content: content,
    })

    // Auto-save
    _ = SaveSession()
}

// ClearSession clears the current session
func ClearSession() error {
    if currentSession == nil {
        return nil
    }

    configDir, err := GetConfigDir()
    if err != nil {
        return err
    }

    sessionPath := filepath.Join(configDir, SessionDirName, CurrentSession)

    if err := os.Remove(sessionPath); err != nil && !os.IsNotExist(err) {
        return err
    }

    currentSession = nil
    return nil
}

func generateSessionID() string {
    return fmt.Sprintf("session-%d", time.Now().Unix())
}
```

**Step 2: Write tests**

Create: `internal/storage/session_test.go`
```go
package storage

import (
    "os"
    "testing"
)

func TestInitSession(t *testing.T) {
    oldHome := os.Getenv("HOME")
    tmpDir, err := os.MkdirTemp("", "tada-test-*")
    if err != nil {
        t.Fatalf("Failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)
    os.Setenv("HOME", tmpDir)
    defer os.Setenv("HOME", oldHome)

    session, err := InitSession()
    if err != nil {
        t.Fatalf("InitSession failed: %v", err)
    }

    if session.ID == "" {
        t.Error("Expected non-empty session ID")
    }
    if len(session.Messages) != 0 {
        t.Errorf("Expected empty messages, got %d", len(session.Messages))
    }
}

func TestAddMessage(t *testing.T) {
    oldHome := os.Getenv("HOME")
    tmpDir, err := os.MkdirTemp("", "tada-test-*")
    if err != nil {
        t.Fatalf("Failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)
    os.Setenv("HOME", tmpDir)
    defer os.Setenv("HOME", oldHome)

    _, _ = InitSession()

    AddMessage("user", "hello")
    AddMessage("assistant", "hi there")

    session := GetCurrentSession()
    if len(session.Messages) != 2 {
        t.Errorf("Expected 2 messages, got %d", len(session.Messages))
    }
    if session.Messages[0].Content != "hello" {
        t.Errorf("Expected 'hello', got '%s'", session.Messages[0].Content)
    }
}

func TestClearSession(t *testing.T) {
    oldHome := os.Getenv("HOME")
    tmpDir, err := os.MkdirTemp("", "tada-test-*")
    if err != nil {
        t.Fatalf("Failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)
    os.Setenv("HOME", tmpDir)
    defer os.Setenv("HOME", oldHome)

    InitSession()
    AddMessage("user", "test")

    err = ClearSession()
    if err != nil {
        t.Fatalf("ClearSession failed: %v", err)
    }

    session := GetCurrentSession()
    if session != nil {
        t.Error("Expected nil session after clear")
    }
}
```

**Step 3: Run tests**

Run:
```bash
go test ./internal/storage/... -v
```

Expected: All tests PASS

**Step 4: Update engine to use session**

Modify: `internal/core/engine.go` (update Process method):
```go
// Add at the beginning of Process method
func (e *Engine) Process(ctx context.Context, input string, systemPrompt string) error {
    // Add user message to session
    session := storage.GetCurrentSession()
    if session != nil {
        storage.AddMessage("user", input)
    }

    // ... rest of the method

    // Add assistant response at the end
    if session != nil {
        storage.AddMessage("assistant", intent.Reason)
    }

    return nil
}
```

**Step 5: Update main.go to initialize session**

Modify: `cmd/tada/main.go` (PersistentPreRunE):
```go
PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
    _, err := storage.InitConfig()
    if err != nil {
        return err
    }
    _, err = storage.InitSession()
    return err
},
```

**Step 6: Commit**

```bash
git add internal/storage/session.go internal/storage/session_test.go internal/core/engine.go cmd/tada/main.go
git commit -m "feat: add session persistence"
```

---

## Task 8: Add Incognito Mode

**Files:**
- Modify: `cmd/tada/main.go`

**Step 1: Add incognito flag**

Modify: `cmd/tada/main.go`
```go
var incognito bool

var rootCmd = &cobra.Command{
    // ... existing code ...
    Run: func(cmd *cobra.Command, args []string) {
        // Skip session init in incognito mode
        if !incognito {
            storage.InitSession()
        }
        // ... rest of Run function
    },
}

func init() {
    rootCmd.PersistentFlags().BoolVarP(&incognito, "incognito", "i", false, "Run in incognito mode (don't save history)")
}
```

**Step 2: Test incognito mode**

Run:
```bash
go run cmd/tada/main.go -i "test command"
```

Expected: Works without creating session file

**Step 3: Commit**

```bash
git add cmd/tada/main.go
git commit -m "feat: add incognito mode"
```

---

## Task 9: End-to-End Testing

**Files:**
- Create: `tests/e2e/mvp_test.go`

**Step 1: Write E2E test**

Create: `tests/e2e/mvp_test.go`
```go
package e2e

import (
    "context"
    "os"
    "testing"
    "time"

    "github.com/Lin-Jiong-HDU/tada/internal/ai/openai"
    "github.com/Lin-Jiong-HDU/tada/internal/core"
    "github.com/Lin-Jiong-HDU/tada/internal/storage"
)

func TestMVP_FullWorkflow(t *testing.T) {
    if os.Getenv("TADA_INTEGRATION_TEST") == "" {
        t.Skip("Set TADA_INTEGRATION_TEST=1 to run E2E tests")
    }

    apiKey := os.Getenv("OPENAI_API_KEY")
    if apiKey == "" {
        t.Skip("OPENAI_API_KEY not set")
    }

    // Setup
    oldHome := os.Getenv("HOME")
    tmpDir, err := os.MkdirTemp("", "tada-e2e-*")
    if err != nil {
        t.Fatalf("Failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)
    os.Setenv("HOME", tmpDir)
    defer os.Setenv("HOME", oldHome)

    // Initialize
    _, err = storage.InitConfig()
    if err != nil {
        t.Fatalf("InitConfig failed: %v", err)
    }

    _, err = storage.InitSession()
    if err != nil {
        t.Fatalf("InitSession failed: %v", err)
    }

    // Create engine
    aiClient := openai.NewClient(apiKey, "gpt-4o-mini", "https://api.openai.com/v1")
    executor := core.NewExecutor(30 * time.Second)
    engine := core.NewEngine(aiClient, executor)

    // Test simple command
    err = engine.Process(context.Background(), "say hello to the world", "")
    if err != nil {
        t.Fatalf("Process failed: %v", err)
    }

    // Verify session was saved
    session := storage.GetCurrentSession()
    if len(session.Messages) < 2 {
        t.Errorf("Expected at least 2 messages in session, got %d", len(session.Messages))
    }

    t.Log("E2E test passed!")
}
```

**Step 2: Run E2E test**

Run:
```bash
TADA_INTEGRATION_TEST=1 OPENAI_API_KEY=your-key go test ./tests/e2e/... -v
```

**Step 3: Commit**

```bash
git add tests/e2e/mvp_test.go
git commit -m "test: add E2E test for MVP"
```

---

## Task 10: Documentation and Cleanup

**Files:**
- Create: `README.md` (update)
- Create: `docs/getting-started.md`

**Step 1: Update README**

Modify: `README.md`
```markdown
# tada ðŸª„

> **"Tada! And it's done."**

`tada` is a lightweight terminal AI assistant written in Go. It understands your intent and automatically executes commands, freeing you from tedious CLI syntax.

## Features

- ðŸ—£ï¸ Natural language interface - just tell it what you want
- ðŸ§  AI-powered intent understanding
- ðŸ’¾ Session persistence with history
- ðŸ”’ Configurable security levels (coming in Phase 2)
- ðŸ”Œ Plugin system (coming in Phase 2)

## Installation

```bash
git clone https://github.com/Lin-Jiong-HDU/tada.git
cd tada
go build -o tada cmd/tada/main.go
sudo mv tada /usr/local/bin/
```

## Configuration

Create `~/.tada/config.yaml`:

```yaml
ai:
  provider: openai
  api_key: sk-xxx  # Your OpenAI API key
  model: gpt-4o-mini
  base_url: https://api.openai.com/v1
  timeout: 30
  max_tokens: 4096
```

## Usage

```bash
# Simple commands
tada "list all files in the current directory"
tada "create a new folder named docs"
tada "say hello to the world"

# Incognito mode (no history saved)
tada -i "run a secret command"
```

## Development

See [docs/getting-started.md](docs/getting-started.md) for development setup.

## Roadmap

- [x] Phase 1: MVP (CLI + AI + Command Execution)
- [ ] Phase 2: Plugins + Security
- [ ] Phase 3: TUI + Async Tasks
- [ ] Phase 4: Multiple AI Providers + i18n

## License

MIT
```

**Step 2: Create getting started guide**

Create: `docs/getting-started.md`
```markdown
# Getting Started with tada Development

## Prerequisites

- Go 1.25.7 or later
- OpenAI API key

## Setup

1. Clone the repository:
```bash
git clone https://github.com/Lin-Jiong-HDU/tada.git
cd tada
```

2. Install dependencies:
```bash
go mod download
```

3. Configure API key:
```bash
mkdir -p ~/.tada
cat > ~/.tada/config.yaml << EOF
ai:
  provider: openai
  api_key: YOUR_API_KEY
  model: gpt-4o-mini
EOF
```

## Running

```bash
go run cmd/tada/main.go "your request here"
```

## Testing

```bash
# Unit tests
go test ./...

# Integration tests (requires API key)
TADA_INTEGRATION_TEST=1 OPENAI_API_KEY=your-key go test ./...
```

## Project Structure

See `docs/plans/2025-02-18-tada-design.md` for architecture details.
```

**Step 3: Commit**

```bash
git add README.md docs/getting-started.md
git commit -m "docs: add getting started guide and update README"
```

---

## Summary

This implementation plan covers the MVP phase of tada:

1. âœ… CLI skeleton with Cobra
2. âœ… Configuration management with Viper
3. âœ… OpenAI provider with HTTP client
4. âœ… Command executor with timeout
5. âœ… Main engine orchestration
6. âœ… Session persistence
7. âœ… Incognito mode
8. âœ… E2E testing
9. âœ… Documentation

**Total estimated time**: 2-3 hours for experienced Go developer

**Next steps after MVP**: See Phase 2 in design document (plugins + security)
